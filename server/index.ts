import express, { Request, Response, NextFunction } from 'express';
import type { CorsOptions, CorsOptionsDelegate } from 'cors';
import { createRequire } from 'module';
import crypto from 'crypto';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import { initializeApp, cert, getApps } from 'firebase-admin/app';
import { getFirestore, FieldValue } from 'firebase-admin/firestore';
import { getAuth } from 'firebase-admin/auth';
import { getExploreIntentDefinition, type ExploreIntentId } from './exploreIntentConfig.js';

const require = createRequire(import.meta.url);
const cors = require('cors/lib/index.js') as (options?: CorsOptions | CorsOptionsDelegate<Request>) => express.RequestHandler;
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function resolveFirstExisting(candidates: string[]): string | null {
  for (const candidate of candidates) {
    const resolved = path.resolve(__dirname, '..', candidate);
    if (fs.existsSync(resolved)) {
      return resolved;
    }
  }
  return null;
}

function loadEnvFiles(): string[] {
  const appEnv = (process.env.APP_ENV || '').toLowerCase();
  const nodeEnv = (process.env.NODE_ENV || '').toLowerCase();
  const runtimeEnv = appEnv || (nodeEnv === 'production' ? 'production' : 'development');
  const loadPlanByEnv: Record<string, string[][]> = {
    development: [['.env.local', 'env.local'], ['.env.development', 'env.development'], ['.env', 'env']],
    staging: [['.env.staging', 'env.staging'], ['.env', 'env']],
    production: [['.env.production', 'env.production'], ['.env', 'env']],
  };
  const loadPlan = loadPlanByEnv[runtimeEnv] || loadPlanByEnv.development;

  const loaded: string[] = [];
  for (const candidates of loadPlan) {
    const envFile = resolveFirstExisting(candidates);
    if (!envFile) continue;
    const result = dotenv.config({ path: envFile, override: false, quiet: true });
    if (!result.error) {
      loaded.push(path.basename(envFile));
    }
  }
  return loaded;
}

const envFilesLoaded = loadEnvFiles();

const placesFromAlias = process.env.GOOGLE_PLACES_API_KEY || process.env.VITE_GOOGLE_PLACES_API_KEY || '';
if (!process.env.PLACES_API_KEY && placesFromAlias) {
  process.env.PLACES_API_KEY = placesFromAlias;
}
const PLACES_API_KEY = process.env.PLACES_API_KEY || '';

// Log startup immediately
console.log('[FamPals API] Starting server...');
console.log('[FamPals API] PORT env:', process.env.PORT);
console.log('[FamPals API] NODE_ENV:', process.env.NODE_ENV);

// Extend Express Request type to include verified user
interface AuthenticatedRequest extends Request {
  uid?: string;
}

function isAdminAccessUser(userData: Record<string, any> | undefined): boolean {
  if (!userData) return false;
  const role = typeof userData.role === 'string' ? userData.role.toLowerCase() : '';
  const entitlementTier = typeof userData?.entitlement?.subscription_tier === 'string'
    ? String(userData.entitlement.subscription_tier).toLowerCase()
    : '';
  const topLevelEntitlement = typeof userData.entitlement === 'string'
    ? String(userData.entitlement).toLowerCase()
    : '';
  return role === 'admin'
    || entitlementTier === 'admin'
    || topLevelEntitlement === 'admin'
    || userData.unlimited_credits === true
    || userData.is_review_account === true;
}

const app = express();

// Health check endpoint - respond BEFORE any initialization or middleware
app.get('/health', (_req, res) => {
  res.status(200).send('OK');
});

const replitDomains = process.env.REPLIT_DOMAINS?.split(',').map((domain) => domain.trim()).filter(Boolean) ?? [];
const replitOrigins = replitDomains.map((domain) => `https://${domain}`);
const allowedOrigins = [
  'https://app.fampal.co.za',
  'http://localhost:3000',
  'http://localhost:5173',
  'http://localhost:5000',
  'http://localhost:8080',
  ...replitOrigins,
];

const isProduction = process.env.NODE_ENV === 'production';
app.use(cors({
  origin: isProduction
    ? (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {
      if (!origin) return callback(null, true);
      if (allowedOrigins.includes(origin)) return callback(null, true);
      return callback(null, false);
    }
    : true,
}));
app.use(express.json({ verify: (req: any, _res, buf) => { req.rawBody = buf; } }));

const PAYSTACK_SECRET_KEY = process.env.PAYSTACK_SECRET_KEY || '';
const PAYSTACK_PUBLIC_KEY = process.env.PAYSTACK_PUBLIC_KEY || '';
const APP_URL = process.env.APP_URL
  || (replitDomains[0] ? `https://${replitDomains[0]}` : 'http://localhost:5000');
const GOOGLE_PLACES_API_KEY = PLACES_API_KEY;
const PLACES_CONFIGURED = !!GOOGLE_PLACES_API_KEY;
const PLACE_REFRESH_MAX_PER_RUN = Math.max(1, Number(process.env.PLACE_REFRESH_MAX_PER_RUN || 30));
const PLACE_REFRESH_CANDIDATE_MULTIPLIER = Math.max(2, Number(process.env.PLACE_REFRESH_CANDIDATE_MULTIPLIER || 4));
const PLACE_REFRESH_CONCURRENCY = Math.max(1, Number(process.env.PLACE_REFRESH_CONCURRENCY || 3));
const PLACE_REFRESH_CRON_TOKEN = process.env.PLACE_REFRESH_CRON_TOKEN || '';

console.log('[FamPals API] Startup config:', {
  port: process.env.PORT || 8080,
  appEnv: process.env.APP_ENV || (process.env.NODE_ENV === 'production' ? 'production' : 'development'),
  nodeEnv: process.env.NODE_ENV,
  envFilesLoaded,
  paystackConfigured: !!PAYSTACK_SECRET_KEY,
  placesConfigured: PLACES_CONFIGURED,
});

// Initialize Firebase Admin SDK
// In production on Cloud Run/App Hosting, uses Application Default Credentials (ADC)
// Can also use FIREBASE_SERVICE_ACCOUNT if explicitly provided
let db: ReturnType<typeof getFirestore>;
let adminAuth: ReturnType<typeof getAuth>;

try {
  if (!getApps().length) {
    if (process.env.FIREBASE_SERVICE_ACCOUNT) {
      const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
      initializeApp({ credential: cert(serviceAccount) });
      console.log('[FamPals API] Initialized with explicit service account');
    } else {
      // Use ADC (works on Cloud Run, App Engine, Cloud Functions)
      initializeApp();
      console.log('[FamPals API] Initialized with Application Default Credentials');
    }
  }
  db = getFirestore();
  adminAuth = getAuth();
  console.log('[FamPals API] Firebase Admin SDK initialized successfully');
} catch (err) {
  console.error('[FamPals API] Firebase Admin init error:', err);
  process.exit(1);
}
// Middleware to verify Firebase Auth token
async function requireAuth(req: AuthenticatedRequest, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid authorization header' });
  }
  
  const idToken = authHeader.split('Bearer ')[1];
  try {
    const decodedToken = await adminAuth.verifyIdToken(idToken);
    req.uid = decodedToken.uid;
    next();
  } catch (err: any) {
    console.error('[FamPals API] Auth verification failed:', err?.message);
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

function requireSchedulerAuth(req: Request, res: Response, next: NextFunction) {
  const tokenFromHeader = (req.headers['x-scheduler-token'] as string) || '';
  const bearer = (req.headers.authorization || '').replace(/^Bearer\s+/i, '').trim();
  const provided = tokenFromHeader || bearer;
  const isProd = process.env.NODE_ENV === 'production';

  if (!PLACE_REFRESH_CRON_TOKEN) {
    if (isProd) {
      return res.status(500).json({ error: 'PLACE_REFRESH_CRON_TOKEN is required in production' });
    }
    console.warn('[FamPals Refresh] PLACE_REFRESH_CRON_TOKEN missing; allowing local/dev execution.');
    next();
    return;
  }

  if (provided !== PLACE_REFRESH_CRON_TOKEN) {
    return res.status(401).json({ error: 'Unauthorized scheduler request' });
  }
  next();
}

type PlaceRefreshOptions = {
  limit?: number;
  dryRun?: boolean;
};

async function fetchGooglePlaceForRefresh(googlePlaceId: string): Promise<any> {
  const response = await fetch(`https://places.googleapis.com/v1/places/${encodeURIComponent(googlePlaceId)}`, {
    headers: {
      'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
      'X-Goog-FieldMask': 'id,displayName,formattedAddress,rating,userRatingCount,types,priceLevel,location,photos,primaryType,primaryTypeDisplayName,googleMapsUri,goodForChildren,menuForChildren,restroom,accessibilityOptions,parkingOptions',
    },
  });
  if (!response.ok) {
    throw new Error(`Google details refresh failed: HTTP ${response.status}`);
  }
  return response.json();
}

async function runPlaceRefreshJob(options: PlaceRefreshOptions = {}) {
  const startedAt = Date.now();
  if (!PLACES_CONFIGURED) {
    return {
      ok: false,
      reason: 'GOOGLE_PLACES_API_KEY missing',
      scannedCount: 0,
      staleCount: 0,
      refreshedCount: 0,
      failedCount: 0,
      skippedCount: 0,
      limitPerRun: 0,
      elapsedMs: 0,
    };
  }

  const limitPerRun = Math.max(1, Math.min(Number(options.limit || PLACE_REFRESH_MAX_PER_RUN), 200));
  const candidateLimit = Math.max(limitPerRun * PLACE_REFRESH_CANDIDATE_MULTIPLIER, limitPerRun);
  const dryRun = options.dryRun === true;
  const now = new Date();
  const staleCandidates: Array<{ id: string; data: any }> = [];

  const snap = await db.collection('places').orderBy('lastRefreshedAt', 'asc').limit(candidateLimit).get();
  snap.docs.forEach((docSnap) => {
    const data = docSnap.data() || {};
    const lastRefreshedAt = data.lastRefreshedAt?.toDate?.() || null;
    const savedCount = Math.max(0, Number(data.savedCount || 0));
    const viewCount = Math.max(0, Number(data.viewCount || 0));
    const popularityScore = Math.max(
      0,
      Number(data.popularityScore || computePopularityScore(savedCount, viewCount, Number(data.userRatingsTotal || 0)))
    );
    const staleAfterDays = computeStaleAfterDays(savedCount, viewCount, popularityScore);
    const staleMillis = staleAfterDays * 24 * 60 * 60 * 1000;
    const staleByLastRefreshed = !lastRefreshedAt || now.getTime() - lastRefreshedAt.getTime() >= staleMillis;
    const nextRefreshAtRaw = data.refreshState?.nextRefreshAt;
    const nextRefreshAt = nextRefreshAtRaw?.toDate?.() || (typeof nextRefreshAtRaw === 'string' ? new Date(nextRefreshAtRaw) : null);
    const staleByNextRefresh = nextRefreshAt instanceof Date && !Number.isNaN(nextRefreshAt.getTime())
      ? nextRefreshAt.getTime() <= now.getTime()
      : false;
    if (staleByLastRefreshed || staleByNextRefresh) {
      staleCandidates.push({ id: docSnap.id, data });
    }
  });

  const staleTargets = staleCandidates
    .filter((item) => typeof item.data.googlePlaceId === 'string' && item.data.googlePlaceId.length > 0)
    .slice(0, limitPerRun);

  let refreshedCount = 0;
  let failedCount = 0;
  let skippedCount = 0;
  const errors: Array<{ placeId: string; error: string }> = [];

  const queue = [...staleTargets];
  const workers = Array.from({ length: PLACE_REFRESH_CONCURRENCY }).map(async () => {
    while (queue.length > 0) {
      const next = queue.shift();
      if (!next) return;
      const placeRef = db.collection('places').doc(next.id);
      const googlePlaceId = String(next.data.googlePlaceId || '');
      if (!googlePlaceId) {
        skippedCount += 1;
        continue;
      }
      const previousFailures = Number(next.data?.refreshState?.consecutiveFailures || 0);
      const requestedCategory = next.data?.categoryContext?.requestedCategory || 'all';
      const savedCount = Math.max(0, Number(next.data.savedCount || 0));
      const viewCount = Math.max(0, Number(next.data.viewCount || 0));

      if (dryRun) {
        refreshedCount += 1;
        continue;
      }

      try {
        await placeRef.set({
          refreshState: {
            ...(next.data.refreshState || {}),
            status: 'refreshing',
            lastAttemptAt: FieldValue.serverTimestamp(),
          },
        }, { merge: true });

        const p = await fetchGooglePlaceForRefresh(googlePlaceId);
        const imageUrl = p.photos?.[0]
          ? `https://places.googleapis.com/v1/${p.photos[0].name}/media?maxHeightPx=400&maxWidthPx=600&key=${GOOGLE_PLACES_API_KEY}`
          : null;
        const source = {
          googlePlaceId: p.id || googlePlaceId,
          name: p.displayName?.text || next.data.name || 'Unknown Place',
          address: p.formattedAddress || next.data.address || '',
          lat: p.location?.latitude || next.data?.geo?.lat || 0,
          lng: p.location?.longitude || next.data?.geo?.lng || 0,
          types: Array.isArray(p.types) ? p.types : [],
          primaryType: p.primaryType || null,
          primaryTypeDisplayName: p.primaryTypeDisplayName?.text || null,
          rating: typeof p.rating === 'number' ? p.rating : null,
          userRatingsTotal: typeof p.userRatingCount === 'number' ? p.userRatingCount : null,
          priceLevel: p.priceLevel || null,
          mapsUrl: p.googleMapsUri || `https://www.google.com/maps/place/?q=place_id:${googlePlaceId}`,
          photoUrl: imageUrl,
          goodForChildren: p.goodForChildren === true,
          menuForChildren: p.menuForChildren === true,
          restroom: p.restroom === true,
          accessibilityOptions: p.accessibilityOptions || {},
          parkingOptions: p.parkingOptions || {},
        };
        const facets = buildFacetSnapshotFromGoogle({
          name: source.name,
          address: source.address,
          types: source.types,
          primaryTypeDisplayName: source.primaryTypeDisplayName || undefined,
          goodForChildren: source.goodForChildren,
          menuForChildren: source.menuForChildren,
          restroom: source.restroom,
          accessibilityOptions: source.accessibilityOptions,
          requestedCategory,
          rating: source.rating || undefined,
          userRatingsTotal: source.userRatingsTotal || undefined,
        });
        const popularityScore = computePopularityScore(savedCount, viewCount, source.userRatingsTotal || undefined);
        const staleAfterDays = computeStaleAfterDays(savedCount, viewCount, popularityScore);
        const nextRefreshAt = new Date(Date.now() + staleAfterDays * 24 * 60 * 60 * 1000);
        const versionHash = crypto
          .createHash('sha256')
          .update(JSON.stringify({
            id: source.googlePlaceId,
            rating: source.rating,
            userRatingsTotal: source.userRatingsTotal,
            priceLevel: source.priceLevel,
            types: source.types,
            lat: source.lat,
            lng: source.lng,
          }))
          .digest('hex')
          .slice(0, 12);

        await placeRef.set({
          placeId: next.id,
          googlePlaceId: source.googlePlaceId,
          name: source.name,
          normalizedName: source.name.toLowerCase().trim(),
          address: source.address,
          geo: { lat: source.lat, lng: source.lng },
          rating: source.rating,
          userRatingsTotal: source.userRatingsTotal,
          priceLevel: source.priceLevel,
          mapsUrl: source.mapsUrl,
          imageUrl: source.photoUrl,
          types: source.types,
          primaryType: source.primaryType,
          facets: {
            categories: facets.categories,
            venueTypes: facets.venueTypes,
            foodTypes: facets.foodTypes,
            kidFriendlySignals: facets.kidFriendlySignals,
            accessibilitySignals: facets.accessibilitySignals,
            indoorOutdoorSignals: facets.indoorOutdoorSignals,
          },
          facetsConfidence: facets.confidence,
          sourceVersions: { google: versionHash },
          popularityScore,
          staleAfterDays,
          savedCount,
          viewCount,
          refreshState: {
            status: 'ready',
            consecutiveFailures: 0,
            lastAttemptAt: FieldValue.serverTimestamp(),
            lastError: null,
            nextRefreshAt,
          },
          lastRefreshedAt: FieldValue.serverTimestamp(),
          updatedAt: FieldValue.serverTimestamp(),
        }, { merge: true });

        await placeRef.collection('sources').doc('google').set({
          googlePlaceId: source.googlePlaceId,
          versionHash,
          fetchedAt: FieldValue.serverTimestamp(),
          requestedCategory,
          searchQuery: null,
          ingestionSource: 'scheduler_refresh',
          source: p,
        }, { merge: true });

        refreshedCount += 1;
      } catch (err: any) {
        failedCount += 1;
        const failureCount = previousFailures + 1;
        const backoffDays = Math.min(30, Math.max(1, 2 ** Math.min(failureCount, 5)));
        const nextRetry = new Date(Date.now() + backoffDays * 24 * 60 * 60 * 1000);
        errors.push({ placeId: next.id, error: err?.message || 'refresh_failed' });
        await placeRef.set({
          refreshState: {
            status: 'error',
            consecutiveFailures: failureCount,
            lastAttemptAt: FieldValue.serverTimestamp(),
            lastError: err?.message || 'refresh_failed',
            nextRefreshAt: nextRetry,
          },
        }, { merge: true });
      }
    }
  });

  await Promise.all(workers);
  const elapsedMs = Date.now() - startedAt;
  console.log('[FamPals Refresh] completed', {
    dryRun,
    scannedCount: snap.size,
    staleCount: staleTargets.length,
    refreshedCount,
    failedCount,
    skippedCount,
    limitPerRun,
    elapsedMs,
  });

  return {
    ok: true,
    dryRun,
    scannedCount: snap.size,
    staleCount: staleTargets.length,
    refreshedCount,
    failedCount,
    skippedCount,
    limitPerRun,
    elapsedMs,
    errors: errors.slice(0, 20),
  };
}

if (!PLACES_CONFIGURED) {
  console.warn('[FamPals API] Google Places API key is not configured. Places search will fail.');
}

const LEGACY_PLACE_TYPE_MAP: Record<string, string | undefined> = {
  restaurant: 'restaurant',
  outdoor: 'park',
  indoor: 'museum',
  active: 'playground',
  hike: 'park',
  wine: 'bar',
  golf: 'golf_course',
  all: undefined,
};

function resolveLegacyType(type?: string | string[]) {
  if (!type) return undefined;
  const key = Array.isArray(type) ? type[0] : type;
  return LEGACY_PLACE_TYPE_MAP[key] || undefined;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function normalizeType(value: string): string {
  return value.toLowerCase().replace(/\s+/g, '_').trim();
}

function normalizeFacetToken(value: string): string {
  return value.toLowerCase().trim().replace(/\s+/g, '_');
}

function computePopularityScore(savedCount: number, viewCount: number, userRatingsTotal?: number): number {
  const ratingsSignal = Math.min(Math.max(userRatingsTotal || 0, 0), 1000);
  return Math.max(0, savedCount * 20 + viewCount + Math.round(ratingsSignal / 10));
}

function computeStaleAfterDays(savedCount: number, viewCount: number, popularityScore: number): number {
  const highEngagement = savedCount >= 10 || viewCount >= 500 || popularityScore >= 120;
  return highEngagement ? 7 : 30;
}

function buildFacetSnapshotFromGoogle(source: {
  name: string;
  address: string;
  types: string[];
  primaryTypeDisplayName?: string;
  goodForChildren?: boolean;
  menuForChildren?: boolean;
  restroom?: boolean;
  accessibilityOptions?: Record<string, unknown>;
  requestedCategory?: string;
  rating?: number;
  userRatingsTotal?: number;
}): {
  categories: string[];
  venueTypes: string[];
  foodTypes: string[];
  kidFriendlySignals: string[];
  accessibilitySignals: string[];
  indoorOutdoorSignals: string[];
  confidence: number;
} {
  const types = (source.types || []).map(normalizeFacetToken);
  const text = `${source.name || ''} ${source.primaryTypeDisplayName || ''} ${source.address || ''}`.toLowerCase();
  const venueTypes = new Set<string>();
  const foodTypes = new Set<string>();
  const kidFriendlySignals = new Set<string>();
  const accessibilitySignals = new Set<string>();
  const indoorOutdoorSignals = new Set<string>();
  const indoorHints = ['museum', 'gallery', 'library', 'cinema', 'mall', 'bowling', 'aquarium', 'indoor'];
  const outdoorHints = ['park', 'trail', 'hike', 'beach', 'garden', 'camp', 'nature', 'outdoor'];

  if (types.includes('restaurant') || types.includes('meal_takeaway') || types.includes('meal_delivery')) venueTypes.add('restaurant');
  if (types.includes('cafe') || types.includes('coffee_shop')) venueTypes.add('cafe');
  if (types.includes('bar') || types.includes('pub')) venueTypes.add('bar_pub');
  if (types.includes('market')) venueTypes.add('market');
  if (types.includes('bakery')) venueTypes.add('bakery');
  if (types.includes('food_truck') || text.includes('food truck')) venueTypes.add('food_truck');
  if (types.includes('winery') || text.includes('wine farm') || text.includes('wine estate') || text.includes('wine tasting')) venueTypes.add('wine_farm');

  ['coffee', 'bakery', 'brunch', 'breakfast', 'pizza', 'sushi', 'burger', 'steak', 'seafood', 'italian', 'pasta', 'indian', 'curry', 'mexican', 'tacos', 'asian', 'thai', 'chinese', 'ice cream', 'gelato', 'farm stall']
    .forEach((keyword) => {
      if (text.includes(keyword)) foodTypes.add(normalizeFacetToken(keyword));
    });

  if (source.goodForChildren) kidFriendlySignals.add('child_friendly_space');
  if (source.menuForChildren) kidFriendlySignals.add('kids_menu');
  if (text.includes('high chair')) kidFriendlySignals.add('high_chair');
  if (text.includes('play area') || text.includes('playground') || text.includes('jungle gym')) kidFriendlySignals.add('play_area_jungle_gym');
  if (text.includes('stroller') || text.includes('pram')) kidFriendlySignals.add('stroller_friendly');

  const accessibilityText = JSON.stringify(source.accessibilityOptions || {}).toLowerCase();
  if (source.restroom || accessibilityText.includes('wheelchair') || accessibilityText.includes('accessible')) {
    accessibilitySignals.add('wheelchair_friendly');
  }
  if (source.restroom || accessibilityText.includes('restroom') || accessibilityText.includes('toilet')) {
    accessibilitySignals.add('accessible_toilet');
  }
  if (text.includes('quiet') || text.includes('calm')) accessibilitySignals.add('quiet_friendly');

  const hasIndoor = types.some((t) => indoorHints.includes(t)) || indoorHints.some((k) => text.includes(k));
  const hasOutdoor = types.some((t) => outdoorHints.includes(t)) || outdoorHints.some((k) => text.includes(k));
  if (hasIndoor) indoorOutdoorSignals.add('indoor');
  if (hasOutdoor) indoorOutdoorSignals.add('outdoor');
  if (hasIndoor && hasOutdoor) indoorOutdoorSignals.add('both');

  const categories = new Set<string>();
  if (types.some((type) => ['restaurant', 'cafe', 'meal_takeaway', 'meal_delivery', 'bakery'].includes(type))) categories.add('restaurant');
  if (types.some((type) => ['park', 'national_park', 'beach', 'campground', 'hiking_area'].includes(type))) categories.add('outdoor');
  if (types.some((type) => ['museum', 'movie_theater', 'library', 'bowling_alley', 'aquarium'].includes(type))) categories.add('indoor');
  if (types.some((type) => ['gym', 'sports_complex', 'swimming_pool', 'amusement_park', 'playground'].includes(type))) categories.add('active');
  if (types.some((type) => ['hiking_area', 'national_park', 'state_park'].includes(type)) || text.includes('hike') || text.includes('trail')) categories.add('hike');
  if (types.some((type) => ['winery', 'vineyard'].includes(type)) || text.includes('wine farm') || text.includes('wine estate') || text.includes('wine tasting')) categories.add('wine');
  if (types.some((type) => ['golf_course'].includes(type)) || text.includes('golf')) categories.add('golf');
  if (types.some((type) => ['playground', 'amusement_park', 'zoo', 'aquarium'].includes(type)) || text.includes('kids') || text.includes('family') || text.includes('child')) categories.add('kids');
  if (categories.size === 0 && source.requestedCategory && source.requestedCategory !== 'all') categories.add(source.requestedCategory);
  if (categories.size === 0) categories.add('all');

  const signalCount =
    (venueTypes.size > 0 ? 1 : 0) +
    (foodTypes.size > 0 ? 1 : 0) +
    (kidFriendlySignals.size > 0 ? 1 : 0) +
    (accessibilitySignals.size > 0 ? 1 : 0) +
    (indoorOutdoorSignals.size > 0 ? 1 : 0);
  const confidence = Math.min(
    0.95,
    0.35 + signalCount * 0.1 + (typeof source.rating === 'number' ? 0.08 : 0) + ((source.userRatingsTotal || 0) >= 20 ? 0.12 : 0)
  );

  return {
    categories: Array.from(categories),
    venueTypes: Array.from(venueTypes),
    foodTypes: Array.from(foodTypes),
    kidFriendlySignals: Array.from(kidFriendlySignals),
    accessibilitySignals: Array.from(accessibilitySignals),
    indoorOutdoorSignals: Array.from(indoorOutdoorSignals),
    confidence: Number(confidence.toFixed(2)),
  };
}

function includesAny(text: string, keywords: string[]): boolean {
  const haystack = text.toLowerCase();
  return keywords.some((keyword) => haystack.includes(keyword.toLowerCase()));
}

interface PlanConfig {
  name: string;
  amount: number;
  currency: string;
  interval: string | null;
  plan_code?: string;
}

const PLANS: Record<string, PlanConfig> = {
  pro: {
    name: 'Pro Plan',
    amount: 5900,
    currency: 'ZAR',
    interval: 'monthly',
    plan_code: process.env.PAYSTACK_PRO_PLAN_CODE || '',
  },
  business_pro: {
    name: 'Business Pro',
    amount: 14900,
    currency: 'ZAR',
    interval: 'monthly',
    plan_code: process.env.PAYSTACK_BUSINESS_PRO_PLAN_CODE || '',
  },
};

function verifyPaystackSignature(rawBody: Buffer, signature: string): boolean {
  if (!PAYSTACK_SECRET_KEY) return false;
  const hash = crypto
    .createHmac('sha512', PAYSTACK_SECRET_KEY)
    .update(rawBody)
    .digest('hex');
  return hash === signature;
}

app.get('/api/health', (_req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    placesConfigured: PLACES_CONFIGURED,
    nodeEnv: process.env.NODE_ENV || 'development',
  });
});

app.post('/api/admin/places/refresh-stale', requireSchedulerAuth, async (req, res) => {
  try {
    const dryRun = req.query.dryRun === 'true' || req.body?.dryRun === true;
    const limit = Number(req.query.limit || req.body?.limit || PLACE_REFRESH_MAX_PER_RUN);
    const result = await runPlaceRefreshJob({ dryRun, limit });
    return res.status(result.ok ? 200 : 500).json(result);
  } catch (error: any) {
    console.error('[FamPals Refresh] endpoint error', error);
    return res.status(500).json({ ok: false, error: error?.message || 'place_refresh_failed' });
  }
});

app.get('/api/places/nearby', async (req, res) => {
  try {
    const apiKey = GOOGLE_PLACES_API_KEY || (typeof req.query.apiKey === 'string' ? req.query.apiKey : '');
    if (!apiKey) {
      return res.status(500).json({ error: 'Places API not configured' });
    }
    if (!GOOGLE_PLACES_API_KEY && apiKey) {
      console.warn('[FamPals API] Using client-provided Places API key for nearby search.');
    }
    const lat = Number(req.query.lat);
    const lng = Number(req.query.lng);
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return res.status(400).json({ error: 'Missing or invalid lat/lng' });
    }
    const radiusKm = Number(req.query.radiusKm || 10);
    const radiusMeters = Math.min(Math.max(radiusKm, 0.1) * 1000, 50000);
    const pageToken = typeof req.query.pageToken === 'string' ? req.query.pageToken : undefined;
    const typeParam = typeof req.query.type === 'string' ? req.query.type : undefined;
    const legacyType = resolveLegacyType(typeParam);

    const params = new URLSearchParams({
      key: apiKey,
      location: `${lat},${lng}`,
      radius: `${radiusMeters}`,
    });
    if (legacyType) {
      params.set('type', legacyType);
    }
    if (pageToken) {
      params.set('pagetoken', pageToken);
    }

    const url = `https://maps.googleapis.com/maps/api/place/nearbysearch/json?${params.toString()}`;
    const response = await fetch(url);
    const data = await response.json();

    if (data.status === 'INVALID_REQUEST' && pageToken) {
      return res.status(409).json({ error: 'page_token_not_ready' });
    }
    if (data.status && data.status !== 'OK' && data.status !== 'ZERO_RESULTS') {
      return res.status(400).json({ error: data.error_message || data.status, status: data.status });
    }
    return res.json({
      results: data.results || [],
      nextPageToken: data.next_page_token || null,
      hasMore: !!data.next_page_token,
    });
  } catch (error) {
    console.error('Places nearby error:', error);
    return res.status(500).json({ error: 'Places search failed' });
  }
});

app.get('/api/places/text', async (req, res) => {
  try {
    const apiKey = GOOGLE_PLACES_API_KEY || (typeof req.query.apiKey === 'string' ? req.query.apiKey : '');
    if (!apiKey) {
      return res.status(500).json({ error: 'Places API not configured' });
    }
    if (!GOOGLE_PLACES_API_KEY && apiKey) {
      console.warn('[FamPals API] Using client-provided Places API key for text search.');
    }
    const query = typeof req.query.query === 'string' ? req.query.query.trim() : '';
    if (!query) {
      return res.status(400).json({ error: 'Missing query' });
    }
    const lat = Number(req.query.lat);
    const lng = Number(req.query.lng);
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return res.status(400).json({ error: 'Missing or invalid lat/lng' });
    }
    const radiusKm = Number(req.query.radiusKm || 10);
    const radiusMeters = Math.min(Math.max(radiusKm, 0.1) * 1000, 50000);
    const pageToken = typeof req.query.pageToken === 'string' ? req.query.pageToken : undefined;

    const params = new URLSearchParams({
      key: apiKey,
      query: `${query} family friendly`,
      location: `${lat},${lng}`,
      radius: `${radiusMeters}`,
    });
    if (pageToken) {
      params.set('pagetoken', pageToken);
    }

    const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?${params.toString()}`;
    const response = await fetch(url);
    const data = await response.json();

    if (data.status === 'INVALID_REQUEST' && pageToken) {
      return res.status(409).json({ error: 'page_token_not_ready' });
    }
    if (data.status && data.status !== 'OK' && data.status !== 'ZERO_RESULTS') {
      return res.status(400).json({ error: data.error_message || data.status, status: data.status });
    }
    return res.json({
      results: data.results || [],
      nextPageToken: data.next_page_token || null,
      hasMore: !!data.next_page_token,
    });
  } catch (error) {
    console.error('Places text search error:', error);
    return res.status(500).json({ error: 'Places search failed' });
  }
});

app.get('/api/places/intent', async (req, res) => {
  try {
    const apiKey = GOOGLE_PLACES_API_KEY || (typeof req.query.apiKey === 'string' ? req.query.apiKey : '');
    if (!apiKey) {
      return res.status(500).json({ error: 'Places API not configured' });
    }
    const intent = (typeof req.query.intent === 'string' ? req.query.intent : 'all') as ExploreIntentId;
    const lat = Number(req.query.lat);
    const lng = Number(req.query.lng);
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return res.status(400).json({ error: 'Missing or invalid lat/lng' });
    }
    const radiusKm = Number(req.query.radiusKm || 10);
    const radiusMeters = Math.min(Math.max(radiusKm, 0.1) * 1000, 50000);
    const searchQuery = typeof req.query.searchQuery === 'string' ? req.query.searchQuery.trim() : '';
    const definition = getExploreIntentDefinition(intent);
    const queries = Array.from(
      new Set((searchQuery ? [searchQuery, ...definition.queries.slice(0, 2)] : definition.queries).map((q) => q.toLowerCase().trim()))
    );

    const dedupeMap = new Map<string, any>();
    const perQueryCounts: Record<string, { pagesFetched: number; fetchedResults: number; uniqueAdded: number }> = {};

    console.log(`[FamPals API] Explore intent selected: ${intent}`);
    console.log(`[FamPals API] Intent queries executed: ${queries.join(', ')}`);

    for (const query of queries) {
      let nextPageToken: string | undefined = undefined;
      let hasMore = true;
      let page = 1;
      let fetchedResults = 0;
      const beforeUnique = dedupeMap.size;

      while (page <= 3 && hasMore) {
        if (page > 1) {
          await sleep(2000);
        }

        const params = new URLSearchParams({
          key: apiKey,
          query: query,
          location: `${lat},${lng}`,
          radius: `${radiusMeters}`,
        });
        if (nextPageToken) {
          params.set('pagetoken', nextPageToken);
        }

        const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?${params.toString()}`;
        const response = await fetch(url);
        const data = await response.json();

        if (data.status === 'INVALID_REQUEST' && nextPageToken) {
          await sleep(2000);
          continue;
        }
        if (data.status && data.status !== 'OK' && data.status !== 'ZERO_RESULTS') {
          console.warn('[FamPals API] Intent text search warning:', data.status, data.error_message || '');
          break;
        }

        const results = Array.isArray(data.results) ? data.results : [];
        fetchedResults += results.length;
        for (const result of results) {
          const placeId = result?.place_id || result?.id;
          if (!placeId) continue;
          dedupeMap.set(placeId, result);
        }

        const mergedResults = Array.from(dedupeMap.values());
        const filtered = mergedResults.filter((place) => {
          const types = (Array.isArray(place?.types) ? place.types : []).map((t: string) => normalizeType(t));
          const typeSet = new Set(types);
          const text = `${place?.name || ''} ${place?.formatted_address || ''}`.toLowerCase();
          const includeTypes = definition.includeTypes.map(normalizeType);
          const excludeTypes = definition.excludeTypes.map(normalizeType);

          if (includesAny(text, definition.keywordExclude)) return false;
          if (excludeTypes.some((type) => typeSet.has(type))) return false;
          if (includeTypes.length === 0) return true;
          if (includeTypes.some((type) => typeSet.has(type))) return true;
          return includesAny(text, definition.keywordInclude);
        });

        perQueryCounts[query] = {
          pagesFetched: page,
          fetchedResults,
          uniqueAdded: dedupeMap.size - beforeUnique,
        };

        console.log(`[FamPals API] Query "${query}" page ${page}: ${results.length} results, hasMore: ${!!data.next_page_token}`);
        console.log(`[FamPals API] Merge count after "${query}" page ${page}: ${mergedResults.length} before filter, ${filtered.length} after filter`);

        nextPageToken = data.next_page_token || undefined;
        hasMore = !!nextPageToken;
        page += 1;
      }
    }

    const mergedResults = Array.from(dedupeMap.values());
    const filteredResults = mergedResults.filter((place) => {
      const types = (Array.isArray(place?.types) ? place.types : []).map((t: string) => normalizeType(t));
      const typeSet = new Set(types);
      const text = `${place?.name || ''} ${place?.formatted_address || ''}`.toLowerCase();
      const includeTypes = definition.includeTypes.map(normalizeType);
      const excludeTypes = definition.excludeTypes.map(normalizeType);

      if (includesAny(text, definition.keywordExclude)) return false;
      if (excludeTypes.some((type) => typeSet.has(type))) return false;
      if (includeTypes.length === 0) return true;
      if (includeTypes.some((type) => typeSet.has(type))) return true;
      return includesAny(text, definition.keywordInclude);
    });

    console.log(`[FamPals API] Intent "${intent}" filter counts: before=${mergedResults.length}, after=${filteredResults.length}`);

    return res.json({
      places: filteredResults,
      results: filteredResults,
      hasMore: false,
      nextPageToken: null,
      debug: {
        intent,
        subtitle: definition.subtitle,
        queriesRun: queries,
        perQueryCounts,
        totalBeforeFilter: mergedResults.length,
        totalAfterFilter: filteredResults.length,
      },
    });
  } catch (error) {
    console.error('Places intent search error:', error);
    return res.status(500).json({ error: 'Places intent search failed' });
  }
});

app.get('/api/subscription/status/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.json({ entitlement: null });
    }
    
    const data = userDoc.data();
    return res.json({ entitlement: data?.entitlement || null });
  } catch (error) {
    console.error('Error fetching subscription status:', error);
    return res.status(500).json({ error: 'Failed to fetch status' });
  }
});

app.post('/api/paystack/init-payment', async (req, res) => {
  try {
    const { userId, email, plan } = req.body;
    
    if (!userId || !email || !plan) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    if (!PAYSTACK_SECRET_KEY) {
      return res.status(500).json({ error: 'Payment system not configured' });
    }
    
    const planConfig = PLANS[plan as keyof typeof PLANS];
    if (!planConfig) {
      return res.status(400).json({ error: 'Invalid plan' });
    }
    
    const reference = `fampals_${plan}_${userId}_${Date.now()}`;
    const callbackUrl = `${APP_URL}?payment_callback=true&ref=${reference}`;
    
    let paystackPayload: any = {
      email,
      amount: planConfig.amount,
      currency: planConfig.currency,
      reference,
      callback_url: callbackUrl,
      metadata: {
        userId,
        plan,
        custom_fields: [
          { display_name: 'Plan', variable_name: 'plan', value: plan },
          { display_name: 'User ID', variable_name: 'user_id', value: userId }
        ]
      }
    };
    
    if (plan === 'pro' && planConfig.plan_code) {
      paystackPayload.plan = planConfig.plan_code;
    }
    
    const response = await fetch('https://api.paystack.co/transaction/initialize', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${PAYSTACK_SECRET_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(paystackPayload),
    });
    
    const data = await response.json();
    
    if (!data.status) {
      console.error('Paystack init error:', data);
      return res.status(400).json({ error: data.message || 'Payment initialization failed' });
    }
    
    return res.json({
      authorization_url: data.data.authorization_url,
      access_code: data.data.access_code,
      reference: data.data.reference,
    });
  } catch (error) {
    console.error('Payment init error:', error);
    return res.status(500).json({ error: 'Payment initialization failed' });
  }
});

app.post('/api/paystack/verify', async (req, res) => {
  try {
    const { reference } = req.body;
    
    if (!reference || !PAYSTACK_SECRET_KEY) {
      return res.status(400).json({ error: 'Invalid request' });
    }
    
    const response = await fetch(`https://api.paystack.co/transaction/verify/${reference}`, {
      headers: {
        Authorization: `Bearer ${PAYSTACK_SECRET_KEY}`,
      },
    });
    
    const data = await response.json();
    
    if (!data.status || data.data.status !== 'success') {
      return res.status(400).json({ error: 'Payment not verified' });
    }
    
    const metadata = data.data.metadata;
    const userId = metadata?.userId;
    const plan = metadata?.plan;
    
    if (userId && plan) {
      await updateUserEntitlement(userId, plan, data.data.reference, data.data);
    }
    
    return res.json({ success: true, plan });
  } catch (error) {
    console.error('Verification error:', error);
    return res.status(500).json({ error: 'Verification failed' });
  }
});

app.post('/api/paystack/webhook', async (req: any, res) => {
  try {
    const signature = req.headers['x-paystack-signature'] as string;
    
    if (!signature || !verifyPaystackSignature(req.rawBody, signature)) {
      console.error('Invalid webhook signature');
      return res.status(401).json({ error: 'Invalid signature' });
    }
    
    const event = req.body;
    console.log('Paystack webhook event:', event.event);
    
    switch (event.event) {
      case 'charge.success':
      case 'subscription.create': {
        const metadata = event.data.metadata;
        const userId = metadata?.userId;
        const plan = metadata?.plan;
        
        if (userId && plan) {
          await updateUserEntitlement(userId, plan, event.data.reference, event.data);
          console.log(`Updated entitlement for user ${userId} to ${plan}`);
        }
        break;
      }
      
      case 'subscription.disable':
      case 'subscription.not_renew': {
        const subscriptionCode = event.data.subscription_code;
        const userSnapshot = await db.collection('users')
          .where('entitlement.paystack_subscription_code', '==', subscriptionCode)
          .limit(1)
          .get();
        
        if (!userSnapshot.empty) {
          const userDoc = userSnapshot.docs[0];
          const userData = userDoc.data() as Record<string, any> | undefined;
          if (isAdminAccessUser(userData)) {
            console.log(`[FamPals API] Skipped cancellation downgrade for admin/review account ${userDoc.id}`);
            break;
          }
          await userDoc.ref.update({
            'entitlement.plan_status': 'cancelled',
          });
          console.log(`Cancelled subscription for user ${userDoc.id}`);
        }
        break;
      }
      
      case 'invoice.payment_failed': {
        const customerCode = event.data.customer?.customer_code;
        if (customerCode) {
          const userSnapshot = await db.collection('users')
            .where('entitlement.paystack_customer_code', '==', customerCode)
            .limit(1)
            .get();
          
          if (!userSnapshot.empty) {
            const userDoc = userSnapshot.docs[0];
            const userData = userDoc.data() as Record<string, any> | undefined;
            if (isAdminAccessUser(userData)) {
              console.log(`[FamPals API] Skipped expiry downgrade for admin/review account ${userDoc.id}`);
              break;
            }
            await userDoc.ref.update({
              'entitlement.plan_status': 'expired',
            });
          }
        }
        break;
      }
    }
    
    return res.json({ received: true });
  } catch (error) {
    console.error('Webhook error:', error);
    return res.status(500).json({ error: 'Webhook processing failed' });
  }
});

app.post('/api/subscription/cancel', async (req, res) => {
  try {
    const { userId } = req.body;
    
    if (!userId || !PAYSTACK_SECRET_KEY) {
      return res.status(400).json({ error: 'Invalid request' });
    }
    
    const userDoc = await db.collection('users').doc(userId).get();
    const userData = userDoc.data();
    if (isAdminAccessUser(userData as Record<string, any> | undefined)) {
      return res.json({ success: true, skipped: true, reason: 'admin_review_account' });
    }
    const subscriptionCode = userData?.entitlement?.paystack_subscription_code;
    const emailToken = userData?.entitlement?.paystack_email_token;
    
    if (!subscriptionCode) {
      return res.status(400).json({ error: 'No active subscription' });
    }
    
    const response = await fetch(`https://api.paystack.co/subscription/disable`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${PAYSTACK_SECRET_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ code: subscriptionCode, token: emailToken }),
    });
    
    const data = await response.json();
    
    if (data.status) {
      await userDoc.ref.update({
        'entitlement.plan_status': 'cancelled',
      });
      return res.json({ success: true });
    }
    
    return res.status(400).json({ error: 'Failed to cancel subscription' });
  } catch (error) {
    console.error('Cancel error:', error);
    return res.status(500).json({ error: 'Cancellation failed' });
  }
});

async function updateUserEntitlement(
  userId: string, 
  plan: string, 
  reference: string,
  paymentData: any
) {
  const userRef = db.collection('users').doc(userId);
  const existingUserDoc = await userRef.get();
  const existingUserData = existingUserDoc.exists ? (existingUserDoc.data() as Record<string, any>) : undefined;
  if (isAdminAccessUser(existingUserData)) {
    console.log(`[FamPals API] Skipped entitlement overwrite for admin/review account ${userId}`);
    return;
  }
  const now = new Date();
  let endDate: string | null = null;
  const oneMonthLater = new Date(now);
  oneMonthLater.setMonth(oneMonthLater.getMonth() + 1);
  endDate = oneMonthLater.toISOString();
  
  const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
  
  const entitlement = {
    plan_tier: 'pro' as const,
    plan_status: 'active',
    entitlement_source: 'paystack',
    entitlement_start_date: now.toISOString(),
    entitlement_end_date: endDate,
    paystack_customer_code: paymentData.customer?.customer_code || null,
    paystack_subscription_code: paymentData.subscription_code || null,
    paystack_email_token: paymentData.email_token || paymentData.subscription?.email_token || null,
    last_payment_reference: reference,
    ai_requests_this_month: 0,
    ai_requests_reset_date: nextMonth.toISOString(),
  };
  
  await userRef.set(
    { entitlement },
    { merge: true }
  );
}

app.get('/api/paystack/config', (_req, res) => {
  res.json({ 
    publicKey: PAYSTACK_PUBLIC_KEY,
    configured: !!PAYSTACK_SECRET_KEY 
  });
});

// Partner unlink endpoint - handles clearing both users' partnerLink fields
// This is needed because Firestore rules only allow users to write to their own documents
// Requires Firebase Auth token for security
app.post('/api/partner/unlink', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!; // Verified user from auth token
    
    console.log('[FamPals API] Partner unlink request for user:', userId);
    
    // Fetch user's current partnerLink to get the actual partnerId
    const userDoc = await db.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const userData = userDoc.data() || {};
    const currentPartnerLink = userData.partnerLink;
    
    // Get the actual partner from user's document (not from request body for security)
    const actualPartnerUserId = currentPartnerLink?.partnerUserId;
    
    console.log('[FamPals API] Validated partner from user doc:', actualPartnerUserId);
    
    const batch = db.batch();
    
    // Clear current user's partnerLink
    const userRef = db.collection('users').doc(userId);
    batch.update(userRef, { partnerLink: FieldValue.delete() });
    
    // If there's a valid partner link, clear their partnerLink too
    if (actualPartnerUserId) {
      const partnerRef = db.collection('users').doc(actualPartnerUserId);
      batch.update(partnerRef, { partnerLink: FieldValue.delete() });
      
      // Also mark the partner thread as closed
      const threadId = [userId, actualPartnerUserId].sort().join('_');
      const threadRef = db.collection('partnerThreads').doc(threadId);
      batch.set(threadRef, { status: 'closed', updatedAt: FieldValue.serverTimestamp() }, { merge: true });
    }
    
    await batch.commit();
    console.log('[FamPals API] Partner unlink successful');
    
    res.json({ success: true });
  } catch (err: any) {
    console.error('[FamPals API] Partner unlink failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to unlink partner', details: err?.message });
  }
});

// Refresh partner status - returns current partner link info for the authenticated user
// Requires Firebase Auth token for security
app.get('/api/partner/status', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!; // Verified user from auth token
    
    const userDoc = await db.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      return res.json({ partnerLink: null });
    }
    
    const userData = userDoc.data() || {};
    const partnerLink = userData.partnerLink ? { ...userData.partnerLink } : null;
    
    // If linked, also get partner's current profile info
    if (partnerLink?.partnerUserId) {
      const partnerDoc = await db.collection('users').doc(partnerLink.partnerUserId).get();
      if (partnerDoc.exists) {
        const partnerData = partnerDoc.data() || {};
        const partnerProfile = partnerData.profile || {};
        partnerLink.partnerName = partnerProfile.displayName || partnerLink.partnerName;
        partnerLink.partnerEmail = partnerProfile.email || partnerLink.partnerEmail;
        partnerLink.partnerPhotoURL = partnerProfile.photoURL || partnerLink.partnerPhotoURL;
      }
    }
    
    res.json({ partnerLink });
  } catch (err: any) {
    console.error('[FamPals API] Partner status fetch failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to fetch partner status', details: err?.message });
  }
});

// Partner link endpoint - handles linking two users when accepting an invite code
// Requires Firebase Auth token for security
// Validates that the invite code matches the partner's pending code
app.post('/api/partner/link', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!; // Verified user from auth token
    const { partnerUserId, partnerName, selfName, inviteCode } = req.body;
    
    if (!partnerUserId) {
      return res.status(400).json({ error: 'Missing partnerUserId' });
    }
    
    console.log('[FamPals API] Partner link request:', { userId, partnerUserId });
    
    // Get partner's info and validate invite code
    const partnerDoc = await db.collection('users').doc(partnerUserId).get();
    if (!partnerDoc.exists) {
      return res.status(404).json({ error: 'Partner not found' });
    }
    const partnerData = partnerDoc.data() || {};
    const partnerProfile = partnerData.profile || {};
    
    // Validate invite code matches partner's pending invite
    const partnerInviteCode = partnerData.partnerLink?.inviteCode;
    const partnerStatus = partnerData.partnerLink?.status;
    
    // If invite code is provided, validate it matches
    if (inviteCode && partnerInviteCode !== inviteCode) {
      console.log('[FamPals API] Invite code mismatch:', { provided: inviteCode, expected: partnerInviteCode });
      return res.status(403).json({ error: 'Invalid invite code' });
    }
    
    // Validate partner has a pending invite code
    if (!partnerInviteCode || partnerStatus === 'accepted') {
      console.log('[FamPals API] Partner does not have a pending invite or is already linked');
      return res.status(400).json({ error: 'Partner does not have a pending invite or is already linked' });
    }
    
    // Get current user's info to update partner's record
    const userDoc = await db.collection('users').doc(userId).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const userProfile = userData?.profile || {};
    
    const batch = db.batch();
    
    // Update current user's partnerLink to accepted
    const userRef = db.collection('users').doc(userId);
    batch.set(userRef, {
      partnerLink: {
        status: 'accepted',
        inviteCode: partnerData.partnerLink?.inviteCode || '',
        createdAt: FieldValue.serverTimestamp(),
        partnerUserId,
        partnerName: partnerProfile.displayName || partnerName || 'Partner',
        partnerEmail: partnerProfile.email,
        partnerPhotoURL: partnerProfile.photoURL,
      }
    }, { merge: true });
    
    // Update partner's partnerLink to mark them as linked
    const partnerRef = db.collection('users').doc(partnerUserId);
    batch.set(partnerRef, {
      partnerLink: {
        status: 'accepted',
        inviteCode: partnerData.partnerLink?.inviteCode || '',
        createdAt: FieldValue.serverTimestamp(),
        partnerUserId: userId,
        partnerName: userProfile.displayName || selfName || 'Partner',
        partnerEmail: userProfile.email,
        partnerPhotoURL: userProfile.photoURL,
      }
    }, { merge: true });
    
    // Create partner thread
    const threadId = [userId, partnerUserId].sort().join('_');
    const threadRef = db.collection('partnerThreads').doc(threadId);
    batch.set(threadRef, {
      members: [userId, partnerUserId],
      createdAt: FieldValue.serverTimestamp(),
      status: 'active',
    }, { merge: true });
    
    await batch.commit();
    console.log('[FamPals API] Partner link successful');
    
    res.json({ 
      success: true, 
      partnerLink: {
        status: 'accepted',
        partnerUserId,
        partnerName: partnerProfile.displayName || partnerName || 'Partner',
        partnerEmail: partnerProfile.email,
        partnerPhotoURL: partnerProfile.photoURL,
      }
    });
  } catch (err: any) {
    console.error('[FamPals API] Partner link failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to link partner', details: err?.message });
  }
});

//  Place Owner Claim & Management 

app.post('/api/place-claims', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!;
    const { placeId, placeName, businessRole, businessEmail, businessPhone, verificationMethod, verificationEvidence } = req.body;

    if (!placeId || !placeName || !businessRole || !verificationEvidence) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const existing = await db.collection('placeClaims')
      .where('placeId', '==', placeId)
      .where('userId', '==', userId)
      .where('status', '==', 'pending')
      .get();

    if (!existing.empty) {
      return res.status(409).json({ error: 'You already have a pending claim for this place' });
    }

    const verifiedExisting = await db.collection('placeClaims')
      .where('placeId', '==', placeId)
      .where('status', '==', 'verified')
      .get();

    if (!verifiedExisting.empty) {
      return res.status(409).json({ error: 'This place already has a verified owner' });
    }

    const userRecord = await adminAuth.getUser(userId);

    const claim = {
      placeId,
      placeName,
      userId,
      userEmail: userRecord.email || '',
      userDisplayName: userRecord.displayName || '',
      status: 'pending',
      businessRole,
      businessEmail: businessEmail || null,
      businessPhone: businessPhone || null,
      verificationMethod: verificationMethod || 'manual',
      verificationEvidence,
      createdAt: FieldValue.serverTimestamp(),
    };

    const docRef = await db.collection('placeClaims').add(claim);

    await db.collection('places').doc(placeId).set({
      ownerStatus: 'pending',
    }, { merge: true });

    console.log(`[FamPals API] Place claim submitted: ${docRef.id} for place ${placeId} by ${userId}`);
    res.json({ success: true, claimId: docRef.id });
  } catch (err: any) {
    console.error('[FamPals API] Place claim submission failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to submit claim' });
  }
});

app.get('/api/place-claims/my-claims', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!;
    const snapshot = await db.collection('placeClaims')
      .where('userId', '==', userId)
      .orderBy('createdAt', 'desc')
      .get();

    const claims = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.()?.toISOString?.() || data.createdAt,
        reviewedAt: data.reviewedAt?.toDate?.()?.toISOString?.() || data.reviewedAt,
      };
    });
    res.json({ claims });
  } catch (err: any) {
    console.error('[FamPals API] Fetch my claims failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to fetch claims' });
  }
});

app.get('/api/place-claims/place/:placeId', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { placeId } = req.params;
    const userId = req.uid!;

    const snapshot = await db.collection('placeClaims')
      .where('placeId', '==', placeId)
      .where('userId', '==', userId)
      .orderBy('createdAt', 'desc')
      .limit(1)
      .get();

    if (snapshot.empty) {
      return res.json({ claim: null });
    }

    const doc = snapshot.docs[0];
    res.json({ claim: { id: doc.id, ...doc.data() } });
  } catch (err: any) {
    console.error('[FamPals API] Fetch place claim failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to fetch claim' });
  }
});

app.get('/api/admin/place-claims', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!;
    const userDoc = await db.collection('users').doc(userId).get();
    const userData = userDoc.data();
    if (!userData?.isAdmin) {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const status = (req.query.status as string) || 'pending';
    const snapshot = await db.collection('placeClaims')
      .where('status', '==', status)
      .orderBy('createdAt', 'desc')
      .limit(50)
      .get();

    const claims = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.()?.toISOString?.() || data.createdAt,
        reviewedAt: data.reviewedAt?.toDate?.()?.toISOString?.() || data.reviewedAt,
      };
    });
    res.json({ claims });
  } catch (err: any) {
    console.error('[FamPals API] Admin fetch claims failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to fetch claims' });
  }
});

app.post('/api/admin/place-claims/:claimId/verify', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const adminUserId = req.uid!;
    const userDoc = await db.collection('users').doc(adminUserId).get();
    const userData = userDoc.data();
    if (!userData?.isAdmin) {
      return res.status(403).json({ error: 'Admin access required' });
    }

    const claimId = req.params.claimId as string;
    const { action, rejectionReason } = req.body;

    if (!['verify', 'reject'].includes(action)) {
      return res.status(400).json({ error: 'Invalid action' });
    }

    const claimRef = db.collection('placeClaims').doc(claimId);
    const claimDoc = await claimRef.get();

    if (!claimDoc.exists) {
      return res.status(404).json({ error: 'Claim not found' });
    }

    const claimData = claimDoc.data()!;
    const batch = db.batch();

    if (action === 'verify') {
      batch.update(claimRef, {
        status: 'verified',
        reviewedAt: FieldValue.serverTimestamp(),
        reviewedBy: adminUserId,
      });

      const placeRef = db.collection('places').doc(claimData.placeId);
      batch.set(placeRef, {
        ownerStatus: 'verified',
        ownerTier: 'free',
        ownerIds: FieldValue.arrayUnion(claimData.userId),
        updatedAt: FieldValue.serverTimestamp(),
      }, { merge: true });

      const ownerProfileRef = db.collection('placeOwnerProfiles').doc(`${claimData.placeId}_${claimData.userId}`);
      batch.set(ownerProfileRef, {
        placeId: claimData.placeId,
        userId: claimData.userId,
        tier: 'free',
        verifiedAt: new Date().toISOString(),
        ownerContent: {},
        lastUpdatedAt: new Date().toISOString(),
      });

      console.log(`[FamPals API] Claim ${claimId} verified for place ${claimData.placeId}`);
    } else {
      batch.update(claimRef, {
        status: 'rejected',
        rejectionReason: rejectionReason || 'Insufficient evidence',
        reviewedAt: FieldValue.serverTimestamp(),
        reviewedBy: adminUserId,
      });

      batch.set(db.collection('places').doc(claimData.placeId), {
        ownerStatus: 'none',
      }, { merge: true });

      console.log(`[FamPals API] Claim ${claimId} rejected for place ${claimData.placeId}`);
    }

    await batch.commit();
    res.json({ success: true, status: action === 'verify' ? 'verified' : 'rejected' });
  } catch (err: any) {
    console.error('[FamPals API] Admin claim verification failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to process claim' });
  }
});

app.get('/api/place-owner/:placeId', async (req: Request, res: Response) => {
  try {
    const placeId = req.params.placeId as string;
    const placeDoc = await db.collection('places').doc(placeId).get();

    if (!placeDoc.exists) {
      return res.json({ ownerStatus: 'none', ownerContent: null });
    }

    const data = placeDoc.data()!;
    res.json({
      ownerStatus: data.ownerStatus || 'none',
      ownerTier: data.ownerTier || null,
      ownerContent: data.ownerContent || null,
      promotedUntil: data.promotedUntil || null,
    });
  } catch (err: any) {
    console.error('[FamPals API] Fetch place owner info failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to fetch owner info' });
  }
});

app.put('/api/place-owner/:placeId/content', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!;
    const placeId = req.params.placeId as string;
    const { ownerContent } = req.body;

    const placeDoc = await db.collection('places').doc(placeId).get();
    if (!placeDoc.exists) {
      return res.status(404).json({ error: 'Place not found' });
    }

    const placeData = placeDoc.data()!;
    if (!placeData.ownerIds?.includes(userId)) {
      return res.status(403).json({ error: 'You are not a verified owner of this place' });
    }

    const tier = placeData.ownerTier || 'free';
    const sanitized = { ...ownerContent };
    if (tier === 'free') {
      delete sanitized.specialOffers;
      delete sanitized.events;
      delete sanitized.photos;
    }

    await db.collection('places').doc(placeId).set({
      ownerContent: sanitized,
      updatedAt: FieldValue.serverTimestamp(),
    }, { merge: true });

    const profileId = `${placeId}_${userId}`;
    await db.collection('placeOwnerProfiles').doc(profileId).set({
      ownerContent: sanitized,
      lastUpdatedAt: new Date().toISOString(),
    }, { merge: true });

    console.log(`[FamPals API] Owner content updated for place ${placeId} by ${userId}`);
    res.json({ success: true, ownerContent: sanitized });
  } catch (err: any) {
    console.error('[FamPals API] Owner content update failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to update content' });
  }
});

app.post('/api/paystack/init-business-payment', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!;
    const { placeId, email } = req.body;

    if (!placeId || !email) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (!PAYSTACK_SECRET_KEY) {
      return res.status(500).json({ error: 'Payment system not configured' });
    }

    const placeDoc = await db.collection('places').doc(placeId).get();
    if (!placeDoc.exists || !placeDoc.data()?.ownerIds?.includes(userId)) {
      return res.status(403).json({ error: 'You must be a verified owner' });
    }

    const planConfig = PLANS['business_pro'];
    const reference = `fampals_business_pro_${placeId}_${userId}_${Date.now()}`;
    const callbackUrl = `${APP_URL}?payment_callback=true&ref=${reference}&type=business`;

    const paystackPayload: any = {
      email,
      amount: planConfig.amount,
      currency: planConfig.currency,
      reference,
      callback_url: callbackUrl,
      metadata: {
        userId,
        placeId,
        plan: 'business_pro',
        custom_fields: [
          { display_name: 'Plan', variable_name: 'plan', value: 'Business Pro' },
          { display_name: 'Place ID', variable_name: 'place_id', value: placeId },
        ],
      },
    };

    if (planConfig.plan_code) {
      paystackPayload.plan = planConfig.plan_code;
    }

    const response = await fetch('https://api.paystack.co/transaction/initialize', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${PAYSTACK_SECRET_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(paystackPayload),
    });

    const data = await response.json();

    if (!data.status) {
      console.error('[FamPals API] Paystack init failed:', data);
      return res.status(500).json({ error: 'Payment initialization failed' });
    }

    console.log(`[FamPals API] Business payment initialized: ${reference}`);
    res.json({
      authorization_url: data.data.authorization_url,
      reference: data.data.reference,
    });
  } catch (err: any) {
    console.error('[FamPals API] Business payment init failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to initialize payment' });
  }
});

app.post('/api/paystack/verify-business', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { reference } = req.body;

    if (!reference || !PAYSTACK_SECRET_KEY) {
      return res.status(400).json({ error: 'Invalid request' });
    }

    const response = await fetch(`https://api.paystack.co/transaction/verify/${reference}`, {
      headers: {
        Authorization: `Bearer ${PAYSTACK_SECRET_KEY}`,
      },
    });

    const data = await response.json();

    if (!data.status || data.data.status !== 'success') {
      return res.status(400).json({ error: 'Payment not verified' });
    }

    const metadata = data.data.metadata;
    const placeId = metadata?.placeId;
    const userId = metadata?.userId;

    if (placeId && userId) {
      const now = new Date();
      const endDate = new Date(now);
      endDate.setMonth(endDate.getMonth() + 1);

      await db.collection('places').doc(placeId).set({
        ownerTier: 'business_pro',
        promotedUntil: endDate.toISOString(),
        updatedAt: FieldValue.serverTimestamp(),
      }, { merge: true });

      const profileId = `${placeId}_${userId}`;
      await db.collection('placeOwnerProfiles').doc(profileId).set({
        tier: 'business_pro',
        lastUpdatedAt: new Date().toISOString(),
        paystack_reference: reference,
        paystack_subscription_code: data.data.subscription_code || null,
      }, { merge: true });

      console.log(`[FamPals API] Business Pro activated for place ${placeId}`);
    }

    res.json({ success: true, status: 'active' });
  } catch (err: any) {
    console.error('[FamPals API] Business payment verification failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to verify payment' });
  }
});

const VALID_DELETION_CATEGORIES = ['saved_places', 'search_history', 'reviews_notes', 'profile_preferences', 'partner_circles'];

app.post('/api/user/data-deletion', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.uid!;
    const { categories } = req.body;

    if (!Array.isArray(categories) || categories.length === 0) {
      return res.status(400).json({ error: 'No categories specified' });
    }

    const invalid = categories.filter((c: string) => !VALID_DELETION_CATEGORIES.includes(c));
    if (invalid.length > 0) {
      return res.status(400).json({ error: `Invalid categories: ${invalid.join(', ')}` });
    }

    console.log(`[FamPals API] Data deletion request from user ${userId}:`, {
      categories,
      timestamp: new Date().toISOString(),
    });

    res.json({ success: true, message: 'Data deletion request received. Selected data will be removed shortly.' });
  } catch (err: any) {
    console.error('[FamPals API] Data deletion request failed:', err?.message || err);
    res.status(500).json({ error: 'Failed to process data deletion request' });
  }
});

// In production, serve the built frontend
if (isProduction) {
  // Prefer dist relative to compiled server output (dist-server/../dist)
  const distPath = path.resolve(__dirname, '..', 'dist');
  console.log(`[FamPals API] Serving static files from: ${distPath}`);
  console.log(`[FamPals API] Current working directory: ${process.cwd()}`);
  
  // Check if dist folder exists
  if (fs.existsSync(distPath)) {
    console.log(`[FamPals API] dist folder found, serving static files`);
    // Serve static files
    app.use(express.static(distPath));
    
    // Handle client-side routing - serve index.html for all non-API routes
    app.get(/.*/, (req, res) => {
      if (!req.path.startsWith('/api/')) {
        res.sendFile(path.join(distPath, 'index.html'));
      }
    });
  } else {
    console.warn(`[FamPals API] WARNING: dist folder not found at ${distPath}`);
    try {
      console.log(`[FamPals API] Directory contents:`, fs.readdirSync(process.cwd()));
    } catch (err) {
      console.warn('[FamPals API] Unable to read working directory contents:', err);
    }
  }
}

const PORT = process.env.PORT || 8080;
const HOST = '0.0.0.0';

// Start server immediately to satisfy Cloud Run health checks
const server = app.listen(Number(PORT), HOST, () => {
  console.log(`[FamPals API] Server running on ${HOST}:${PORT}`);
  console.log(`[FamPals API] listening on ${PORT}`);
  console.log(`[FamPals API] Environment: ${isProduction ? 'production' : 'development'}`);
  console.log(`[FamPals API] Paystack configured: ${!!PAYSTACK_SECRET_KEY}`);
});

// Handle server errors
server.on('error', (err) => {
  console.error('[FamPals API] Server error:', err);
  process.exit(1);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('[FamPals API] SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('[FamPals API] Server closed');
    process.exit(0);
  });
});
